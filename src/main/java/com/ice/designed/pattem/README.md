# 设计模式
## 设计模式的类型
除GOF23种外的设计模式
* 简单工程模式
  * 由一个工厂决定创建哪一种产品类型的实例
* 创建型模式
  * 隐藏了创建对象的过程,通过逻辑方法进行创建对象,而不是通过new关键字进行创建
    * 工厂方法模式
      * 定义一个接口或一个抽象的工厂类,让它实现类(工厂)来决定创建哪一个实例对象
      * 根据每个工厂不同的方法,来产生不同的所需要的对象
      * 工厂方法模式生产的都是相同类型的对象,比如Java课程,Python课程
    * 抽象工程模式
      * 类型公司下的产品,生产汽车,将汽车分为各个零部件进行生产,车架,车门,底盘
      * 抽象工厂模式提供了创建一系列相关或互相依赖对象的接口
    * 建造者模式
      * 将复杂的对象的创建和属性复制所分离
      * 监造的过程和细节我们不需要知道,只需要通过构建者去进行操作即可
    * 原型模式
      * 用于创建重复的对象,能过保证创建对象的性能.
      * 原型设计模式是创建对象的最佳方法
    * 单例模式
      * 在程序种想要操持一个实例对象的，就是用单例设计模式
      * 减少内存开销
        * 懒汉式
          * 在需要使用对象的时候,才会创建
        * 双重检查
          * 通过两个if判断,加上同步锁进行实现
        * 静态内部类
          * 在单例类种,通过私有的静态内部类,创建单例对象
        * 饿汉式
          *  在调用时,就会创建单例对象,通过静态代码块或静态变量直接初始化
        * 枚举
          * 枚举的方法实现单例模式,是最佳的实现方法
          * 它可以有效防止对单例模式的破坏
            * 序列化和反序列的方法破坏单例模式
              * 通过流讲单例对象,序列化到文件中,然后在反序列读取出来
              * 最终通过反序列化的方式创建出一个对象
              * 发现两个对象的内存地址完全不一致,从而破坏了单例设计模式结构
              * 在单例类种,写一个方法名称必须为readResolve
                * 因为在反序列化创建对象时,是通过反射创建的
                * 反射会调用我们自己的readResolve方法
                * 如果重写了,就代表返回自己的单例对象
                * 如果没有重写,会通过反射的方式创建一个新的对象,从而破坏了单例设计模式
                ```java
                    private Object readResolve() {
                        return doubleCheckSingleton;
                    }
                ```
            * 通过反射的方式破坏单例模式
              * 通过字节码对象,创建构造器对象
              * 通过构造器对象,初始化单例对象
                * 由于单例对象的构造方法是私有化的
                * 调用构造器中的方法,赋予权限,创建单例对象
* 结构型模式
  * 主要关注类和对象的组合关系
  * 继承的概念被用来组合接口和定义组合对象,获得新的功能方式
    * 外观模式
      * 提供了体格同意的接口,用来访问子系统中的一群接口
      * 定义了一个高层接口,让子系统使用更加容易
    * 适配器模式
      * 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁,将一个类的接口转换成客户希望的另外一个接口
      * 适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
      * 这种类型的设计模式属于结构性模式,它结合了两个独立接口的功能
    * 桥接模式
      * 桥接（Bridge）是用于把抽象化与实现话解耦,使得二者可以独立变化
      * 这种类型的设计模式属于结构性模式,它通过提供抽象化和实现化之间的桥接结构,来实现二者的解耦
      * 这种模式涉及到一个座位桥接的接口,使得是天雷的功能独立与接口实现类,这两种类型的类可被结构化改变而互不影响
    * 组合模式
      * 组合模式（Composite Pattern）,又叫部分整体模式,是用于一组相似的对象当作一个单一的对象
      * 组合模式依据树形结构来组合对象,用来表示部分以及整体层次.
      * 这种类型的设计模式属于结构型模式,它创建了对象组的树形结构
      * 这种模式创建了一个包含自己对象组的类,该类提供了修改相同对象组的方式.
      * 通过下面的实例来演示组合模式的用法,实例演示了一个组织中员工的层次结构
    * 代理模式
      * 为对象提供一种代理,以控制这个对象的访问操作
      * 代理对象和目标对象之间起到中介的作用
      * 保护目的对象和增强目标对象
      * 代理模式能将代理对象与真是被调用的目标对象分离
      * 一定程度上降低了系统的耦合度,扩展性好
    * 装饰模式
      * 在原有对象不做改变的基础上,将对象的功能附加上
      * 提供了比继承更有弹性的替代方案（扩展原有对象功能）
      * 扩展一个类的功能或给一个类添加附加职责（业务逻辑）
      * 动态的给一个对象添加功能,这些功能可以在动态的撤销
      * 继承的有力补充,比继承灵活,不改变原有对象的情况下给对象扩展功能
      * 通过使用不同装饰类以及这些装饰类的排列组合,可以实现不同效果
    * 享元模式
      * 提供了减少对象数量从而改善应用所需的对象结构的方式
      * 运用了共享技术有效地支持大量细粒度的对象
      * 总结：减少创建对象的数量,从而减少内存的占用,提升性能
* 行为型模式
  * 主要关注对象之间的通信
    * 模板方法模式
      * 定义了一个算法的架构,并允许子类为一个或多个步骤的实现
      * 模板方法在子类不改变算法结构的情况下,重新定义算法的某些步骤
      * 实现一个算法的不变的部分,并将可变的空间留给子类来完成
      * 子类中公告的行为抽取出来并封装到一个公共父类中,皮面代码重复
    * 迭代器模式
      * 提供方法,顺序方位集合对象中的各个元素,而又不暴露对象的内部表示
      * 为遍历不同的集合结构提供统一的接口,分离了集合对象的遍历行为
    * 策略模式
      * 定义了算法,分别封装起来,它们之间可以互相替换,让算法的变化不会影响到使用算法的用户
      * 如果有大量的if...else...else if...可以通过策略模式进行替换
      * 避免使用多重条件转语句,if...else if...else
      * 提高算法的保密性和安全性
    * 解释器模式
      * 通过给定的语言,定义它的语法和行为,并定义解释器,这个解释器使用来解释语言中的句子
      * 为了解释一种语言,而为语言创建的解释器
      * 某个类型问题出发频次足够高,比如处理日志和不同日志格式
    * 责任链模式
    * 命令模式
    * 中介者模式
    * 备忘录模式
    * 观察者模式
    * 状态模式
    * 访问者模式